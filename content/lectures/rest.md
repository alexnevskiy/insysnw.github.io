+++
title = "REST"
description = "Ограничение HTTP для улучшения сетевого общения"
weight = 4
draft = true
+++

В [лекции по HTTP](/lectures/http) мы выяснили, что HTTP - отличный протокол для передачи страниц.
И даже забежали чуть-чуть вперёд, и обсудили, что передавать можно не страницы целиком, а только данные, т.е. не передавать визуальную составляющую каждый раз.
Это не только позволяет эффективно экономить трафик, но и открывает горизонты взаимодействия с HTTP сервером не только браузером, но и многими другими видами приложений.

Пример "другого" приложения мы и рассмотрим.
Предположим нам необходимо написать консольное приложение, выводящее имя пользователя на GitHub и количество его публичных репозиториев.
Если бы мы разрабатывали графическое приложение, хорошо бы ещё отобразить аватар, так что попробуем заполучить ссылку на него.
Входным параметром возьмём логин.

Мы знаем, что на странице пользователя есть все эти данные.
Посмотрим содержимое страницы пользователя `insysnw`:

```bash
curl 'https://github.com/insysnw'
```
{{ include_expandable_code(file="content/lectures/rest/curl_organization_page", language="html") }}

Результат огромен.
Есть ли в нём необходимые данные?
Легко ли их найти?

Имя пользователя можно было бы найти найти в блоке:
```html
<span class="p-name vcard-fullname d-block overflow-hidden" itemprop="name">
```
, но это если бы по этому адресу находился пользователь, но это организация.
Это показывает вероятность изменения расположения данных в HTML в зависимости от контекста.
Имя для пользователей организации можно найти в теге `<title>`, но только вместе c ` · GitHub`.
Количество публичных репозиториев пользователей можно найти в HTML, а вот для организации это информация не содержится в коде страницы, а заполняется JavaScript кодом.
Изображение пользователя может быть найдено в поле `src` тэга `<image>` с классом `avatar`.

```html
<img itemprop="image" class="avatar flex-shrink-0" ... />
```
Для сравнения вот страница пользователя:
```bash
curl 'https://github.com/ejiek'
```
{{ include_expandable_code(file="content/lectures/rest/curl_user_page", language="html") }}


Чем плоха такая HTML страница для нашей цели?

* Много излишней информации
* Имеющиеся данные бывают смешаны с другими ради отображения
* Отсутствие структуры и типизации данных

Следующим шагом развития идеи передачи именно данных стало использование формата данных, более приспособленного для этих целей.
Сейчас популярным решением является JSON.
Именно его поддержка есть у GitHub:

```bash
curl 'https://api.github.com/users/insysnw'
```

{{ include_expandable_code(file="content/lectures/rest/curl_organization_api", language="json") }}

Мы сразу видим сокращение объёма ответа.
Более того, если выполнить такой же запрос но для пользователя, структура данных не поменяется:

```bash
curl 'https://api.github.com/users/ejiek'
```

{{ include_expandable_code(file="content/lectures/rest/curl_user_api", language="json") }}


Данный адрес сильно отличается от того, что мы использовали ранее.
Предыдущий адрес был предназначен для использования человеком в браузере.
Этот адрес в большей степени предназначен для использования другими программами.
Интерфейс предоставляемый программой для других программ вполне оправданно называется Программным Интерфейсом Приложения или Application programming interface (**API**).
Хотим сразу обратить ваше внимание на произношение [эй-пи-ай], а не [апи].
Именно эту аббревиатуру мы и встречаем в последнем адресе адресе.
Обязательно ли использовать API?
Вовсе нет, ведь часто автоматизацию строят вокруг сайтов, у которых API нет.
Но наличие API сильно упрощает программное взаимодействие.


HTTP с самого своего начала передавал HTML, потом к нему добавились CSS, JS и медиа.
Значит ли это, что для передачи данных без визуальной составляющей валидно использовать HTML без вышеупомянутых добавлений?
HyperText **Markup Language** - язык разметки.
Разметка в данном контексте подразумевает описание специфики отображения.
Получается, что HTML всё ещё хранит в себе ту самую визуальную составляющую, от которой мы хотим отказаться.
Так как при передаче данных нам важны их структура и тип, HTML нам не подходит.
И это 

Вторая проблема намного интереснее.
Идея передачи по HTTP данных достаточно популярна далеко не только в веб
приложениях, но и в приложениях в целом.
Мобильные и desktop версии приложений часто используют HTTP запросы.
Серверные приложения для общения между собой.
Для такого типа коммуникаций визуальная составляющая не только не нужна, она довольно сильно мешает.
Помимо уже упомянутого объёма, сильно усложняется парсинг результатов.
Это вызвано отсутствием прямого соответствия разметки страницы структуре данных.
И необходимостью менять процесс разбора страницы каждый раз, когда меняется визуальная составляющая.

В таком взаимодействии обе стороны представляют программы.

Рассмотрим на примере Github.

Сначала рассмотрим обычную страницу пользователя `insysnw`:


Поиск этой информации был бы намного проще, если бы она была организованная формате, предназначенном для передачи данных, а не отображения страницы.
У GitHub есть API.
Попробуем использовать его:

В данном случае в ответе содержится JSON, в котором есть поля:
`name`,`public_repos` и `avatar_url`.
Намного проще!

# Rest
API GitHub, что мы только что рассмотрели, как и многие другие, является
REST API.
Или RESTy [*рэсти*] API, или RESTfull API.
Используют разные названия для описания этого феномена.
Но что же это такое.

REST (Representational State Transfer)это что-то типо того эмм, да. Вот!
Какой же я молодец, как хорошо поясняю за рэст!

Это подход к построению системы, включающие архитектурные и ещё какие-то
требования.
Мы будем рассматривать REST как набор ограничений на использование HTTP.

Так как REST разрабатывался совместно с первыми версиясм HTTP, многие
требования удовлетворены по умолчанию, так как это заложено в HTTP.

## Клиент-Серверная архитектура

В REST присутствует разделение на клиентскую и серверную составляющие, что
равносильно такому разделению в HTTP.
Так же как и HTTP, клиент и сервер отличаются не тем, что находится в Центре
Обработки Данных(ЦОД) или на домашнем компьютере, а тем, что клиент
инициализирует общение, а сервер отвечает.

## Stateless

Название подразумевает, что какое-то состояние отсутствует.
Но большинство REST API требуют авторизации для доступа к некоторым своим.


Это требование вызвано заложенной в протокол возможностью горизонтального
масштабирования.
То есть конкретный сервис на серверной стороне может присутствовать более
чем в единичном экземпляре.
При этом без дополнительной синхронизации этих сервисов, каждый может
одинаково корректно обработать запрос.
Тем не менее, это не значит, что само взаимодействие не может иметь
состояния.
Например, авторизованный пользователь получет информацию отличную от той,
что получает анонимный.
Для этого такое состояние, сессию, хранят так, чтобы из каждого запроса
сервер мог получить достаточно информации о сессии.

## Кэшируемость

Эта часть тоже целиком лежит в HTTP.
**TODO:** опсать server-side

## Унифицированный интерфейс

Для объяснения данной особенности мы хотим начать с паттерна сетевой
разратоки Data Tranfer Object (DTO).
Он заключается в том, что объект передаваемый по сети не должен иметь прямое
соответсвие с представлением этого объекта на сервере и/или на клиенте.
Так, на сервере объект может хранится в таблице реляционной базы данныех, а
передаваться клиенту в виде JSON.
Но вопрос не только в формате представления, но и в содержании.
Можно смело не добавлять все поля объекта внутреннего представления в DTO,
если того не требует бизнес логика.
Но такое прeобразование должно работать в обе стороны.

Media-type

## Многоуровневая система

Речь идёт о возможности добавления на пути пакетов балансировщика или прокси
без необходимости изменения сервера или клиента.
Эта особенность тоже целиком лежит на HTTP.
Однако это вовсе не значит, что эти уровни абсолютно прозрачны.
Для более подробного изучения вопроса предлагаем ознакомиться с заголовками [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) and [Forwarded](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded)


[Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)

Representational state transfer

## Стандартизация
OpenAPI
