+++
title = "REST"
description = "Ограничение HTTP для улучшения сетевого общения"
weight = 4
draft = true
+++
До этого мы разобрали, что HTTP - отличный протокол для передачи страниц.


Также мы затронули тему перехода от передачи готовых к отображению страниц к
веб-приложениям, способным запрашивать по сети только данные.
Но в чём проблема передачи страницы?
Основных проблем две.
Большой объём передаваемых данных, так как каждый раз передаётся вся
визуальная составляющая.

Вторая проблема намного интереснее.
Идея передачи по HTTP данных достаточно популярна далеко не только в веб
приложениях, но и в приложениях в целом.
Мобильные и desktop версии приложений часто используют HTTP запросы.
Серверные приложения для общения между собой.
Для такого типа коммуникаций визуальная составляющая не только не нужна, она довольно сильно мешает.
Помимо уже упомянутого объёма, сильно усложняется парсинг результатов.
Это вызвано отсутствием прямого соответствия разметки страницы структуре данных.
И необходимостью менять процесс разбора страницы каждый раз, когда меняется визуальная составляющая.

В таком взаимодействии обе стороны представляют программы.
Интерфейс предоставляемый программой для других программ вполне оправданно называется Программным Интерфейсом Приложения или Application programming interface (API).
Хотим сразу обратить ваше внимание на произношение [эй-пи-ай], а не [апи].
Обязательно ли использовать API?
Вовсе нет, ведь часто автоматизацию строют вокруг сайтов, у которых API нет.
Но наличие API сильно упрощает программное взаимодействие.

Рассмотрим на примере Github.
Предположим нам необходимо написать приложение, выводящее имя пользователя и количество публичных репозиториев.
Если бы мы разрабатывали графическое приложение, хорошо бы ещё и аватар прихватить.

Сначала рассмотрим обычную страницу пользователя `insysnw`:

```
curl -i 'https://github.com/insysnw'
```
{{ include_expandable_code(file="content/lectures/rest/curl_user_page", language="html") }}

Результат огромен.
Есть ли в нём необходимые данные?
Легко ли их найти?

Имя пользователя может повезёт найти в блоке `<span class="p-name vcard-fullname d-block overflow-hidden" itemprop="name">`, но в данном примере у нас не пользователь, а организация.
Имя для пользователей и для организации можно найти в теге `<title>`, но только вместе c ` · GitHub`.
Количество публичных репозиториев не передаётся, а заполняется результатом выполнения JavaScript кода.
Изображение пользователя может быть найдено в тэге `<image>` с заданным
классом `avatar`, в поле `src` будет указан путь до изображения:


`<img itemprop="image" class="avatar flex-shrink-0" ... />`

Поиск этой информации был бы намного проще, если бы она была организованная формате, предназначенном для передачи данных, а не отображения страницы.
У GitHub есть API.
Попробуем использовать его:

```
curl https://api.github.com/users/insysnw
```

<details>
    <summary>Expand to see the response</summary>



</details>

В данном случае в ответе содержится JSON, в котором есть поля:
`name`,`public_repos` и `avatar_url`.
Намного проще!

# Rest
API GitHub, что мы только что рассмотрели, как и многие другие, является
REST API.
Или RESTy [*рэсти*] API, или RESTfull API.
Используют разные названия для описания этого феномена.
Но что же это такое.

REST (Representational State Transfer)это что-то типо того эмм, да. Вот!
Какой же я молодец, как хорошо поясняю за рэст!

Это подход к построению системы, включающие архитектурные и ещё какие-то
требования.
Мы будем рассматривать REST как набор ограничений на использование HTTP.

Так как REST разрабатывался совместно с первыми версиясм HTTP, многие
требования удовлетворены по умолчанию, так как это заложено в HTTP.

## Клиент-Серверная архитектура

В REST присутствует разделение на клиентскую и серверную составляющие, что
равносильно такому разделению в HTTP.
Так же как и HTTP, клиент и сервер отличаются не тем, что находится в Центре
Обработки Данных(ЦОД) или на домашнем компьютере, а тем, что клиент
инициализирует общение, а сервер отвечает.

## Stateless

Это подразумевает, что состояние соединения отсутствует.
Речь идёт не про TCP, а про состояние прикладного уровня.
Это требование вызвано заложенной в протокол возможностью горизонтального
масштабирования.
То есть конкрентый сервис на серверной стороне можнет присутствовать более
чем в единичном экземпляре.
При этом без дополнительной синхронизации этих сервисов, каждый может
одинаково корректно обработать запрос.
Тем не менее, это не значит, что само взаимодействие не может иметь
состояния.
Например, авторизованный пользователь получет информацию отличную от той,
что получает анонимный.
Для этого такое состояние, сессию, хранят так, чтобы из каждого запроса
сервер мог получить достаточно информации о сессии.

## Кэшируемость

Эта часть тоже целиком лежит в HTTP.

## Унифицированный интерфейс

Для объяснения данной особенности мы хотим начать с паттерна сетевой
разратоки Data Tranfer Object (DTO).
Он заключается в том, что объект передаваемый по сети не должен иметь прямое
соответсвие с представлением этого объекта на сервере и/или на клиенте.
Так, на сервере объект может хранится в таблице реляционной базы данныех, а
передаваться клиенту в виде JSON.
Но вопрос не только в формате представления, но и в содержании.
Можно смело не добавлять все поля объекта внутреннего представления в DTO,
если того не требует бизнес логика.
Но такое прeобразование должно работать в обе стороны.

Media-type

## Многоуровневая система

Речь идёт о возможности добавления на пути пакетов балансировщика или прокси
без необходимости изменения сервера или клиента.
Эта особенность тоже целиком лежит на HTTP.
Однако это вовсе не значит, что эти уровни не учитываются.


[Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)

Representational state transfer
