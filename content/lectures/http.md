+++
title = "Hypertext Transfer Protocol"
description = "Протокол прикладного уровня в качестве транспорта"
draft = true
weight = 3
+++

До этого в курсе были рассмотрены самодостаточные протоколы прикладного уровня, т.е. они решали конечную задачу: передавали файлы, настраивали узлы сети, конвертировали доменные имена в IP адреса и наоборот.
В этой лекции мы выясним, что некоторые как минимум один из них является отличным транспортом.

Ещё в 1989 Tim Berners-Lee начал работать над идей передачи и отображения текста.
Но это должен быть не просто текст, в текст с ссылками на другие тексты.
Особенность этих ссылок в том, что текст мог находится на совсем другом ресурсе.
Такую концепцию назвали Hypertext, что подразумевало "больше чем текст".

Сердцем этой идеи является протокол **HyperText Transfer Protocol**.
Первая его версия ныне имеет версию **0.9**.
Она хорошо подходила для решения вышеописанной задачи.

Страницы легко отобразить даже без браузера (а их тогда под большинство платформ и не было):

```
$ telnet academy.ejiek.com 80
Trying 188.242.22.225...
Connected to academy.ejiek.com.
Escape character is '^]'.
GET /about_http/page
Hello, I'm pre html text.

Isn't it easy to read?
No mark up nonsense! The question is "How to make a Hypertext out of it"?
The fact it, I don't know what was the idea in HTTP 0.9 (which seemd to be developed before HTML)

Bye.
Connection closed by foreign host.
```

Всё что делает `telnet` - открывает tcp сессию до узла с IP адресом, в который резолвится `academy.ejiek.com`.
Дальше мы сами пишем `GET /about_http/page` в поток, на что сервер выдаёт всё содержимое страницы и закрывает TCP сессию.

**Текст получен, задача выполнена!**

Однако у версии **0.9** есть ещё один трюк в рукаве - [поиск](https://www.w3.org/Addressing/Search.html)!

# Версия 1.0

На сцену выходят браузеры!
А с ними и новые потребности.

Простого отображения текста оказалось мало, возникла **потребность во взаимодействии**.
Так появились **типы запросов** (POST, GET, PUT, DELETE).

Но для адекватного взаимодействия сервера и клиента одних типов запросов недостаточно, нужен **универсальный способ обратной связи**, чтобы сигнализировать об успешном выполнение запроса или наоборот об ошибке.
Тело запроса для этого не подходит, ведь оно может быть каким угодно и ориентировано на человека.
Знакомьтесь, **коды состояния**!
Все из вас наверняка неоднократно видели код `404` или иначе - страница не найдена.
Но мы редко видим коды `2**` или `1**`, хотя сталкиваемся с ними значительно чаще.

Это связано с тем, что эти коды ориентированы на взаимодействие машина-машинa.
Так браузер или любой другой клиент понимает, что что-то пошло не так и может это обработать, а для человека иногда эти коды дублируют в теле ответа.
К слову, это довольно распространённая ошибка: разработчики сервера возвращают правильный код состояния, например, `404`, но в теле ответа, для человека, указывают что-то иное, например, `502`.
Это либо случайная ошибка, либо преднамеренное введение пользователя в заблуждение, что мы не одобряем.
Рядовому пользователю этот код совсем не нужен, в теле ответа достаточно просто показать, что это за ошибка (страница не найдена, нет прав доступа и или любая другая).
А коды успешного подтверждения совсем не принято дублировать в теле ответа, ведь пользователь и так получил то, что хотел.


Подробнее про коды состояний можно почитать в RFC, на сайте [httpstatuses.com](https://httpstatuses.com/) или на [Wikipedia](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP) ([EN](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes))
Мы лишь обсудим, что эти коды делятся на 5 типов.
У каждого типа своя первая цифра:

* 100 - информационные (самое заметное — смена протокола, используется для WebRTC и Web-сокетов)
* 200 - успешное выполнение
* 300 - перенаправление (http ->  https, страница переехала)
* 400 - клиентские ошибки
* 500 - серверные ошибки

## Составные страницы

Из-за активной популяризации браузеров просто текста c ссылками быстро стало недостаточно.
Страницы начали содержать не только текст, но и медиа контент, например, картинки.
Но и это не просто медиа, это HyperMedia

Это же замечательные новости!
Конечно, однако есть довольно большое "НО".

В **0.9** на каждый запрос открывается новое TCP соединение.
То есть для страницы, состоящие из множества ресурсов, необходимо установить столько tcp сессий, сколько на ней ресурсов.
Кажется, что это не очень страшно, пока ресурсов на странице единицы, но вполне обыденно, когда их сотни.
Это достаточно сложно и долго для клиента, открывающего один сайт, и почти невыносимо для сервера, обслуживающего тысячи клиентов.

Решение простое — не закрывать TCP сессию, ведь большинство ресурсов будут получены с одного и того же сервера.

Нельзя просто так взять и поменять поведение протокола.
Это ломает обратную совместимость.
Нужно как-то договориться с сервером, чтобы он не закрывал соединение.
Обсудим, как именно это сделать, уже в следующем разделе.

# Заголовок

На данным момент мы перечислили три важным параметра, которые нужно где-то хранить в HTTP пакете:

* тип запроса
* код состояния
* просьбу не закрывать соединение

Название этого раздела говорит само за себя — Заголовок!
Это набор данных, передаваемый в начале HTTP сообщения, до тела.
Всё дополнительная информация помещается именно туда.

На данном этапе нам достаточно знать, что есть список утверждённых заголовков, но в мире используют не только они.
Иногда заголовки из второй категории попадают в первую.
А ещё они логически делятся на 4 группы:

* Request — специфичные для запросов
* Response — специфичные для ответов
* Entity — описывающие содержимое тела
* General — все остальные


**TODO**: описать Augmented BNF из [rfc 1945](https://tools.ietf.org/html/rfc1945).

В качестве стандартного General заголовка в версии **1.0** появился `connection: keep-alive`.
Такой заголовок в запросе отправляет клиент и если он будет и в ответе сервера, то переговоры удалась и сессия не будет закрыта.

Заголовки типа Entity позволили значительно легче передавать и отображать медиа файлы.
Самый известный из них — `Content-Type`, он хранит тип файла, MIME.
Именно он позволяет понять передаём содержится ли в теле текст, картинка или JSON.

# Версия 1.1

Несмотря на то, что это версия протокола появилась ещё в 1997 году, она до сих пор является основополагающей.
*Но от не стагнировал все эти годы, RFC подвергался обновлениям и полной замене, например, в 2014 году.

Помните `keep-alive`?
Теперь это поведение по умолчанию!

Среди стандартных заголовков появился `Host`.
Если раньше доменное имя терялось (оно не попадало в http сообщение), то теперь оно в нём дублируется.
Это открывает возможность размещать разные доменные адреса с разным содержимом на одном IP адресе.
Именно так работает сайт, который вы сейчас читаете, он дели свой IP в другими сайтами!
Возможность использования Reverse Proxy

# AJAX
При всей сложности составных страниц и крутезне передачи в одной TCP сессии, вопрос перехода на другую страницу остался не затронутым.
При переходе нас всё ещё ждёт загрузка новой страницы целиком.

Чем это плохо?
Когда-то браузеры сопровождали переход полной перерисовка, что на иногда короткое время выглядело как пустая белая страница.
Это особенно печальный пользовательский опыт, если использовать тёмную тему ночью.
Стоит заметить, что такую проблему мы уже давно не замечали.

А вот проблема нагрузки на сеть всё ещё актуальна.
Ведь новая страница потребует элементов пользовательского интерфейса, которые уже присутствуют на текущей.
CSS и некоторые другие ресурсы возможно кешировать, но не HTML.

[Asynchronous JavaScript and XML](https://en.wikipedia.org/wiki/Ajax_(programming)) общее название технологий и техник для динамического обновления сайтов с использованием XML и JS.
Отсюда начинается долгий путь к web приложениям.
Главное изменение - возможность перейти на другую страницу, загрузив только ту часть, которая изменится.

Часто под частью подразумевается, не кусочек страницы, а данные, необходимы для его формирования (без элементов пользовательского интерфейса).
Например, в почтовом ящике при переходе из одной папки в другую, у сервера будет запрошен список писем, а не HTML этим списком.

Подобная практика запроса данных стала достаточно популярной.
Разработчики нашли форматы хранения данных удобнее XML.
Так концепция AJAX осталась в прошлом, но дало начало использованию HTTP не как средства передачи HyperText или HyperMedia, а транспорта.
Сейчас на HTTP строят как тестовые, так и бинарные протоколы обмена данным.

# Single Page Application
SPA - следующая ступень развития оперирования данными.
Вместо, знакомых из AJAX, загрузки страницы сайта и последующего обновления лишь части, в SPA вместо сайта загружается приложение.
Это приложение содержит в себе множество страниц сайта и в некоторых случая работает оффлайн.
За переход между страницами ответственен компонент Router.
Он говорит приложению, какую страницу хочет увидеть пользователь, а браузеру - адрес.
Так без реальных переходов между страницами, а лишь изменением вида одной, создаётся иллюзия настоящего перехода.
Однако для таких манипуляций с историей требуется поддержка более глубокой интеграции со стороны браузера.

Удобство такого приложение в том, что оно использует HTTP как транспорт для данных.
Это, как и прежде, экономия сетевого канала, но и вероятное пересечение API c мобильной и desktop версией приложения.
Что в свою очередь упрощает и удешевляет backend разработку.

# HTTP 2
Мультиплексирование и бинарный заголовок (как и всё остальное)

# HTTP 3
Поверх UDP продумали QUIC (I'm speed)

Установление сессий связи и шифрования объединены
В этот процесс завезли кеширование (клиент знает криптографические параметры сервера)
В рамках одной сессии существуют несколько потоков

# Недостатки HTTP3

UDP является набором пакетов, что усложняет понимание нового протокола.
