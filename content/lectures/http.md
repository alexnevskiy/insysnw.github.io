+++
title = "Введение в Hypertext Transfer Protocol"
description = "Протокол прикладного уровня в качестве транспорта"
draft = true
weight = 3
+++

До этого в курсе были рассмотрены самодостаточные протоколы прикладного уровня, т.е. они решали конечную задачу: передавали файлы, настраивали узлы сети, конвертировали доменные имена в IP адреса и наоборот.
В этой лекции мы выясним, что некоторые как минимум один из них является отличным транспортом.

Ещё в 1989 Tim Berners-Lee начал работать над идей передачи и отображения текста.
Но это должен быть не просто текст, в текст с ссылками на другие тексты.
Особенность этих ссылок в том, что текст мог находится на совсем другом ресурсе.
Такую концепцию назвали Hypertext, что подразумевало "больше чем текст".

Сердцем этой идеи является протокол **HyperText Transfer Protocol**.
Первая его версия ныне имеет версию **0.9**.
Она хорошо подходила для решения вышеописанной задачи.

Страницы легко отобразить даже без браузера (а их тогда под большинство платформ и не было):

```
$ telnet academy.ejiek.com 80
Trying 188.242.22.225...
Connected to academy.ejiek.com.
Escape character is '^]'.
GET /about_http/page
Hello, I'm pre html text.

Isn't it easy to read?
No mark up nonsense! The question is "How to make a Hypertext out of it"?
The fact it, I don't know what was the idea in HTTP 0.9 (which seemd to be developed before HTML)

Bye.
Connection closed by foreign host.
```

Всё что делает `telnet` - открывает tcp сессию до узла с IP адресом, в который резолвится `academy.ejiek.com`.
Дальше мы сами пишем `GET /about_http/page` в поток, на что сервер выдаёт всё содержимое страницы и закрывает TCP сессию.

**Текст получен, задача выполнена!**

Однако у версии **0.9** есть ещё один трюк в рукаве - [поиск](https://www.w3.org/Addressing/Search.html)!


# Версия 1.0


На сцену выходят браузеры!
А с ними и новые потребности.

Простого отображения текста оказалось мало, возникла **потребность во взаимодействии**.
Так появились **типы запросов** (POST, GET, PUT, DELETE).

Но для адекватного взаимодействия сервера и клиента одних типов запросов недостаточно, нужен **универсальный способ обратной связи**, чтобы сигнализировать об успешном выполнение запроса или наоборот об ошибке.
Тело запроса для этого не подходит, ведь оно может быть каким угодно и ориентировано на человека.
Знакомьтесь, **коды состояния**!
Все из вас наверняка неоднократно видели код `404` или иначе - страница не найдена.
Но мы редко видим коды `2**` или `1**`, хотя сталкиваемся с ними значительно чаще.

Это связано с тем, что эти коды ориентированы на взаимодействие машина-машинa.
Так браузер или любой другой клиент понимает, что что-то пошло не так и может это обработать, а для человека иногда эти коды дублируют в теле ответа.
К слову, это довольно распространённая ошибка: разработчики сервера возвращают правильный код состояния, например, `404`, но в теле ответа, для человека, указывают что-то иное, например, `502`.
Это либо случайная ошибка, либо преднамеренное введение пользователя в заблуждение, что мы не одобряем.
Рядовому пользователю этот код совсем не нужен, в теле ответа достаточно просто показать, что это за ошибка (страница не найдена, нет прав доступа и или любая другая).
А коды успешного подтверждения совсем не принято дублировать в теле ответа, ведь пользователь и так получил то, что хотел.


Подробнее про коды состояний можно почитать в RFC, на сайте [httpstatuses.com](https://httpstatuses.com/) или на [Wikipedia](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP) ([EN](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes))
Мы лишь обсудим, что эти коды делятся на 5 типов.
У каждого типа своя первая цифра:

* 100 - информационные (самое заметное - смена протокола, используется для WebRTC и Web-сокетов)
* 200 - успешное выполнение
* 300 - перенаправление (http ->  https, страница переехала)
* 400 - клиентские ошибки
* 500 - серверные ошибки

## Составные страницы

В 0.9 на каждый запрос открывалось новое соединение, но с активной популяризацией браузеров просто текста ссылками стало недостаточно.
Страницы начали содержать не только текст, 

потребовался способ сообщить серверу, что не нужно закрывать соединение.

# Где хранить?

* тип запросв
* код состояния
* просьбу не закрывать соединение (`connection: keep-alive`)

# Заголовок (описать проблему, потом выдать как решение)

Нужен для обмена дополнительной информацией между клиентом и сервером.
Разделяют на несколько групп:

* General
* Request
* Response
* Entity

Можно рассказать про формат заголовков (не знаю, насколько надо)

Применение заголовков позволило передавать не только HTML файлы (`Content-Type`)

# 1.1

Keep-alive стал поведением по умолчанию о.О

Заголовок `Host` предоставил возможность ?хостить? несколько доменов на одном IP адресе.
Возможность использования Reverse Proxy

AJAX

Позволяет обновить часть страницы.

Single Page Application

Для разных страниц используется одно и то же приложение, а взаимодействие с сервером происходит "чистыми" данными

Сокращает нагрузку на сеть, сервер, клиент
Может даже работать offline
Win-win

* Router позволяет отслеживать состояние приложения и навицироваться по
отслеживаемым состояниям.


https://httpstatuses.com/ <- ??

# HTTP 2
Мультиплексирование и бинарный заголовок (как и всё отстальное)

# HTTP 3
Поверх UDP продумали QUIC (I'm speed)

Установление сессий связи и шифрования объединены
В этот процесс завезли кеширование (клиент знает криптографические параметры сервера)
В рамках одной сессии существуют несколько потоков

# Недостатки HTTP3

UDP является набором пакетов, что усложняет понимание нового протокола.

# Открываем Dev Toolskgg
