+++
title = "Transmission Control Protocol"
description = "Теория и примеры использования потоковых сокетов."
weight = 1
+++

В вводной лекции мы затронули тему простоты использования потоковых сокетов.
Далее мы разберём, что именно это значит и за счёт чего работает.

Скрывают за собой протокол транспортного уровня - TCP.
Такие сокеты создают надёжные двунаправленные потоки между двумя узлами.
Это позволяет почти беззаботно писать в сокет и читать из него.
Что такое "надёжные"?
Нет, это не абсолютно устойчивые ко всему соединения, в том числе полному отключению сети или хотя бы её смене (Wifi <-> Мобильное соединени).
Конкретное значение увидим в Datagram сокетах.

**Datagram** сокеты оперируют блоками данных и в целом всё.
Название пришло от скрываемого за ними протокола - User **Datagram** Protocol.
В такие сокеты тоже можно просто писать и читать.
И это даже будет работать.
Но ровно до тех пор, пока ваша сеть идеальна, а данные не вылезают за границы размера пакета.
До этого потоковые сокеты позволяли совсем не думать о пакетах, ведь там ядро реализовывало всю логику TCP само, а нам, программистам выдавало уже готовые данные.
Поток ничем искусственно не ограничен и может быть бесконечно длинным.
С блоком данных - будь добр, уложись в ограничения одного пакета!

Велика беда, разбей большой блок на маленькие и передай?
К сожалению, нет.
Пакеты по пути могут потеряться, продублироваться или даже перемешаться.
Обо всём этом теперь нужно думать программисту.
Но пакеты ещё ведь могут и повредиться?
Это - то немногое, что UDP позволяет проверить.
В пакете может быть хэш данных и заголовка, но в версии IPv4 оно не обязательно.

**Raw** (сырые) сокеты не скрывают за собой протокол транспортного уровня.
Это позволяет работать напрямую с IP пакетом.
Данный тип мы рассматривать не будет, так как он используется значительно реже остальных.
Обычно это разработка нового протокола транспортного уровня или специфичное взаимодействие с имеющимися.

# TCP
Теперь, когда мы уже упомянули потоковые сокеты, давайте рассмотрим протокол, обеспечивающий их работу.

TCP - сессионный протокол.
Это значит, что прежде чем начать отправлять данные, ему необходимо установить сессию, т.е. обменяться рукопожатием с другим узлом:

![Изображение TCP рукопожатия](images/tcp_handshake.png)

Если сессию открыть не удалось, то мы узнаём об отсутствие связи с другим узлом ещё до того, как отправим настоящие данные.

Но вот сессия установлена, что это нам даёт?

Потоки!
Ранее мы обсуждали, что в потоковые сокеты можно просто 
## Общение

## Плавающее окно (как расширение общения)

## Завершение TCP сессии

![](images/tcp_termination.png)


# Утечка ресурсов

Некоторые браузеры известны тем, что со временем поедают всё больше и больше оперативной памяти.

. . .

Сокеты тоже ресурс

## Пример проблемы незакрытия сокета

# Binding (address:port)
::: notes

Могут быть разные ресурсы, ибо биндятся они на разные адреса

:::

```
127.0.0.1:8080
127.0.0.2:8080
```

## Binding на всех адресах

```
0.0.0.0:8081
```

## Ограничения
::: notes

* Зарезервированные требуют прав
* Права хорошо бы дропать
* Их всё равно можно использовать как угодно
* Спросить почему последний именно 65535 (16 бит поля в заголовке)

:::

* 0-1023
* 1024-65535


