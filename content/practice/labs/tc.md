+++
title = 'Эмуляция неблагоприятный условий сети'
weight = 3
[taxonomies]
categories = ["Лабораторная"]
+++

В этой лабораторной нас ждёт знакомство с утилитой `tc` (traffic control).
Она является частью пакета `iproute2` и представлена в большинстве дистрибутивов Linux.

Говорящее название утилиты не врёт.
А самый важный аспект управления трафиком для нас - эмуляция поведения сети.
Разрабатывая приложение локально, мы используем loopback интерфейс, а это почти самые идеальные условия из возможных.
Это позволяет легко забыть, как неблагоприятен реальный мир.
И разработать ПО, которое не будет в нём корректно функционировать.

Мобильный телефон посреди поля, далеко за пределами крупного города, вряд ли сможет найти 5G с максимальным уровнем сигнала.
Хорошо, если это будет сеть третьего поколения больше, чем с одной "палочкой".
В такой ситуации страдает не только пропускная способность канала, но и количество потерь, целостность пакетов.

Как много клиентов будут пользоваться нашим приложением в таких условиях?
В полях нужно наслаждаться природой, а не в телефоне сидеть!
Трактор от John Deere или их конкурентов, может выступить в роли несогласного телефона, уверенного работающего в поле.

К сожалению, есть примеры плохих сетевых условий, куда более близкие к повседневной жизни.
Неудачно расставленные WiFi точки доступа в офисе и учебном кампусе.
Многоквартирные дома с "шумными" WiFi каналами.
Проводное подключение тоже не решение всех проблем.
Провод, неудачно проложенный рядом с силовой линией, может иметь количество потерь не совместимое с его работоспособностью.

Traffic control позволяет имитировать проблемы возникающие во всех вышеупомянутых условиях.
И ещё чуть-чуть.

## Задержка

Прежде, чем вносить изменения снимем исходные показания.

``` sh
ping -c 10 github.com
```

C большой вероятностью, обошлось без потерь пакетов, а значения задержки могут быть меньше одной миллисекунды.

Добавим константную задержку:

```sh
tc qdisc add dev eth0 root netem delay 200ms
```

К значениям задержки добавятся те самые 200 мс.
Если упражнение выполняется на удалённом сервере, то ощутимой должна стать и задержка при работе по ssh.
Ведь и это тоже сетевое взаимодействие, а мы только что добавили по 1/5 секунды на каждый вывод информации пользователю.

Вывод текущего состояния:

```sh
tc qdisc show  dev eth0
```

Очистка всех egress правил

```sh
tc qdisc del dev eth0 root
```

Добавим правило с динамическим распределением задержки:

```sh
tc qdisc add dev eth0 root netem delay 50ms 5ms
```

Изменим имеющееся правило, добавив корреляцию (TODO: докинуть, кого и с кем и зачем)
```sh
tc qdisc change dev eth0 root netem delay 50ms 5ms 25%
```

Также можно указать тип распределения (`normal`, `pareto` и `paretonormal`):

```sh
tc qdisc change dev eth0 root netem delay 50ms 10ms distribution normal
```

## Потеря пакетов

```sh
tc qdisc add dev eth0 root netem loss 10%
```

## Перемешивание пакетов

```sh
reorder
```

## Повреждение пакетов

Имитируем изменение одного случайного бита:

```sh
tc qdisc change dev eth0 root netem corrupt 5%
```

## Дyбликация пакета

```sh
tc qdisc change dev eth0 root netem duplicate 1%
```

## Ограничение пропускной способности

```sh
tc qdisc add dev eth0 root tbf rate 1mbit burst 32kbit latency 400ms
```

# Extra

Как губить не всю сеть - фильтры
